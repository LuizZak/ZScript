using System.Collections.Generic;

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;

using ZScript.CodeGeneration.Messages;
using ZScript.Runtime;

namespace ZScript.CodeGeneration
{
    /// <summary>
    /// Helper entry point for the ZScript library
    /// </summary>
    public class ZScriptGenerator
    {
        /// <summary>
        /// The input string to parse
        /// </summary>
        private string _input;

        /// <summary>
        /// The error listener for the parsing of the script
        /// </summary>
        private ZScriptErrorListener _errorListener;

        /// <summary>
        /// The parse tree that was generated by the parser
        /// </summary>
        private IParseTree _tree;

        /// <summary>
        /// The parser for the currently parsed script
        /// </summary>
        private ZScriptParser _parser;

        /// <summary>
        /// Gets or sets the script string input
        /// </summary>
        public string Input
        {
            get { return _input; }
            set { _input = value; }
        }

        /// <summary>
        /// Returns the array of all the syntax errors that were found during the parsing of the script
        /// </summary>
        public SyntaxError[] SyntaxErrors
        {
            get { return _errorListener.SyntaxErrors.ToArray(); }
        }

        /// <summary>
        /// Gets a value specifying whether there were any syntax errors on the script generation process
        /// </summary>
        public bool HasSyntaxErrors
        {
            get { return _errorListener != null && _errorListener.SyntaxErrors.Count > 0; }
        }

        /// <summary>
        /// Creates a new instance of the ZScriptGenerator class using a specified string as input
        /// </summary>
        /// <param name="input">The input string containing the code to parse</param>
        public ZScriptGenerator(string input)
        {
            _input = input;
        }

        /// <summary>
        /// Parses the input string
        /// </summary>
        public void ParseInputString()
        {
            _errorListener = new ZScriptErrorListener();

            AntlrInputStream stream = new AntlrInputStream(_input);
            ITokenSource lexer = new ZScriptLexer(stream);
            ITokenStream tokens = new CommonTokenStream(lexer);
            
            _parser = new ZScriptParser(tokens)
            {
                BuildParseTree = true,
                ErrorHandler = new BailErrorStrategy(),
                Interpreter = {PredictionMode = PredictionMode.Sll}
            };

            _parser.AddErrorListener(_errorListener);

            try
            {
                _tree = _parser.program();
            }
            // Deal with parse exceptions
            catch (ParseCanceledException)
            {
                _parser.ErrorHandler = new DefaultErrorStrategy();
                _parser.Interpreter.PredictionMode = PredictionMode.Ll;
            }
        }

        /// <summary>
        /// Generates a new runtime based on the script that was parsed, setting the provided runtime owner as the owner of the runtime object to create
        /// </summary>
        /// <param name="owner">A runtime owner object that will own the runtime to be created</param>
        /// <returns>A newly created ZRuntime object that can be used to execute the parsed code</returns>
        public ZRuntime GenerateRuntime(IRuntimeOwner owner)
        {
            var runtimeDefinition = new ZRuntimeDefinition();

            var walker = new ParseTreeWalker();
            var functionListener = new FunctionBlockListener(runtimeDefinition);
            
            walker.Walk(functionListener, _tree);

            return new ZRuntime(runtimeDefinition, owner);
        }

        /// <summary>
        /// Error listener for the parsing
        /// </summary>
        private class ZScriptErrorListener : BaseErrorListener
        {
            /// <summary>
            /// A list of all the syntax errors reported
            /// </summary>
            public readonly List<SyntaxError> SyntaxErrors = new List<SyntaxError>();

            // 
            // SintaxError listener
            // 
            public override void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e)
            {
                SyntaxErrors.Add(new SyntaxError(line, charPositionInLine, msg));
            }
        }

        /// <summary>
        /// Base class for runtime-generation node listeners
        /// </summary>
        private abstract class ZScriptNodeListener : ZScriptBaseListener
        {
            /// <summary>
            /// The runtime definition to populate with this listener
            /// </summary>
            protected readonly ZRuntimeDefinition RuntimeDefinition;

            /// <summary>
            /// Initializes a new instance of the ZScriptNodeListener class
            /// </summary>
            /// <param name="runtimeDefinition">The runtime to generate code to</param>
            protected ZScriptNodeListener(ZRuntimeDefinition runtimeDefinition)
            {
                RuntimeDefinition = runtimeDefinition;
            }
        }

        /// <summary>
        /// Listener that binds functions to the hlobal 
        /// </summary>
        private class FunctionBlockListener : ZScriptNodeListener
        {
            /// <summary>
            /// Whether this function generator is currently traversing a function block
            /// </summary>
            private bool inFunctionBlock;

            /// <summary>
            /// Initializes a new FunctionNodeListener class instance
            /// </summary>
            /// <param name="runtimeDefinition">The runtime to generate code for</param>
            public FunctionBlockListener(ZRuntimeDefinition runtimeDefinition) : base(runtimeDefinition) { }

            // EnterFunctionBlock override
            public override void EnterFunctionBlock(ZScriptParser.FunctionBlockContext context)
            {
                base.EnterFunctionBlock(context);

                inFunctionBlock = true;
            }

            // ExitFunctionBlock override
            public override void ExitFunctionBlock(ZScriptParser.FunctionBlockContext context)
            {
                base.ExitFunctionBlock(context);

                inFunctionBlock = false;
            }

            // EnterFunctionDefinition override
            public override void EnterFunctionDefinition(ZScriptParser.FunctionDefinitionContext context)
            {
                base.EnterFunctionDefinition(context);

                RuntimeDefinition.AddFunctionDef(GenerateFunctionDef(context));
            }

            public override void ExitFunctionDefinition(ZScriptParser.FunctionDefinitionContext context)
            {
                base.ExitFunctionDefinition(context);
            }

            /// <summary>
            /// Generates a new function definition using the given context
            /// </summary>
            /// <param name="context">The context to generate the function definition from</param>
            /// <returns>A function definition generated from the given context</returns>
            public FunctionDef GenerateFunctionDef(ZScriptParser.FunctionDefinitionContext context)
            {
                FunctionDef definition = new FunctionDef { Name = context.functionName().IDENT().GetText() };

                var state = context.blockStatement();

                // TODO: Find a way to tokenize the statements
                var statements = state.statement();

                return definition;
            }
        }
    }
}