#region License information
/*
    ZScript Game Scripting Programming Language
    Copyright (C) 2015  Luiz Fernando Silva

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#endregion

using System;
using System.Collections.Generic;
using System.Linq;

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using JetBrains.Annotations;
using ZScript.Builders;

using ZScript.CodeGeneration.Analysis;
using ZScript.CodeGeneration.Analysis.Definitions;
using ZScript.CodeGeneration.Definitions;
using ZScript.CodeGeneration.Messages;
using ZScript.CodeGeneration.Sourcing;
using ZScript.CodeGeneration.Tokenization;
using ZScript.CodeGeneration.Tokenization.Helpers;
using ZScript.CodeGeneration.Tokenization.Statements;

using ZScript.Elements;
using ZScript.Elements.ValueHolding;

using ZScript.Parsing;
using ZScript.Parsing.ANTLR;
using ZScript.Runtime;
using ZScript.Runtime.Typing;
using ZScript.Runtime.Typing.Elements;

namespace ZScript.CodeGeneration
{
    /// <summary>
    /// Helper entry point for the ZScript library
    /// </summary>
    public class ZRuntimeGenerator
    {
        /// <summary>
        /// Whether to debug the process in the console
        /// </summary>
        public bool Debug;

        /// <summary>
        /// Current sources used during parsing/collection of definisions
        /// </summary>
        private ZScriptDefinitionsSource[] _currentSources = { };

        /// <summary>
        /// The container for error and warning messages
        /// </summary>
        private MessageContainer _messageContainer;

        /// <summary>
        /// The error listener for the parsing of the script
        /// </summary>
        private readonly ZScriptSyntaxErrorListener _syntaxErrorListener;

        /// <summary>
        /// The parser for the currently parsed script
        /// </summary>
        private ZScriptParser _parser;

        /// <summary>
        /// The internal type provider used to generate typing for the definitions
        /// </summary>
        private readonly TypeProvider _typeProvider;

        /// <summary>
        /// The native type builder used during generation time
        /// </summary>
        private readonly NativeTypeBuilder _nativeTypeBuilder;

        /// <summary>
        /// Gets a value specifying whether there were any syntax errors on the script generation process
        /// </summary>
        public bool HasSyntaxErrors => _messageContainer.HasSyntaxErrors;

        /// <summary>
        /// Gets a value specifying whether there are any syntax or code error pending on this runtime generator
        /// </summary>
        public bool HasErrors => _messageContainer.HasErrors;

        /// <summary>
        /// Gets or sets the message container for this scope analyzer
        /// </summary>
        public MessageContainer MessageContainer
        {
            get => _messageContainer;
            set
            {
                _messageContainer = value;
                _syntaxErrorListener.MessageContainer = value;
            }
        }

        /// <summary>
        /// Gets the sources provider for this runtime generator
        /// </summary>
        public ZScriptMultipleSourcesProvider SourceProvider { set; get; }

        /// <summary>
        /// Gets the internal type provider used to generate typing for the definitions
        /// </summary>
        public TypeProvider TypeProvider => _typeProvider;

        /// <summary>
        /// Gets the last code scope generated by a call to <see cref="CollectDefinitions"/>
        /// </summary>
        [CanBeNull]
        public CodeScope LastCodeScope { get; private set; }

        /// <summary>
        /// Creates a new instance of the <see cref="ZRuntimeGenerator"/> class using a specified string as input
        /// </summary>
        public ZRuntimeGenerator()
        {
            _typeProvider = new TypeProvider();
            _messageContainer = new MessageContainer();
            _syntaxErrorListener = new ZScriptSyntaxErrorListener(_messageContainer);
            _nativeTypeBuilder = new NativeTypeBuilder("ZScript_Assembly");

            SourceProvider = new SourceProvider();
        }

        /// <summary>
        /// Creates a new instance of the <see cref="ZRuntimeGenerator"/> class using a specified string as input
        /// </summary>
        /// <param name="input">The input string containing the code to parse</param>
        public ZRuntimeGenerator(string input)
            : this()
        {
            // Add a string source to the provider
            var provider = new SourceProvider();
            provider.AddSource(new ZScriptStringSource(input));

            SourceProvider = provider;
        }

        /// <summary>
        /// Creates a new instance of the <see cref="ZRuntimeGenerator"/> class using a specified script source
        /// </summary>
        /// <param name="source">The source to fetch code to compile from</param>
        public ZRuntimeGenerator([JetBrains.Annotations.NotNull] ZScriptDefinitionsSource source)
            : this()
        {
            // Add a string source to the provider
            var provider = new SourceProvider();
            provider.AddSource(source);

            SourceProvider = provider;
        }

        /// <summary>
        /// Creates a new instance of the ZScriptGenerator class using a specified provider
        /// </summary>
        /// <param name="provider">The provider to push sources from</param>
        public ZRuntimeGenerator(ZScriptMultipleSourcesProvider provider)
            : this()
        {
            SourceProvider = provider;
        }

        /// <summary>
        /// Creates a new runtime generation context from the given scope
        /// </summary>
        /// <param name="scope">The scope to create the generation context around of</param>
        /// <returns>A new RuntimeGenerationContext created from the given scope</returns>
        private RuntimeGenerationContext CreateContext(CodeScope scope)
        {
            var context = new RuntimeGenerationContext(scope, _messageContainer, _typeProvider);
            context.ContextTypeProvider = new ExpressionTypeResolver(context);
            var definitionTypeProvider = new DefaultDefinitionTypeProvider(context);

            // Assign the context
            context.DefinitionTypeProvider = definitionTypeProvider;

            // Register the native type source for the calss native type source
            context.TypeProvider.RegisterCustomNativeTypeSource(_nativeTypeBuilder);

            return context;
        }

        /// <summary>
        /// Parses the input string
        /// </summary>
        public void ParseSources()
        {
            _messageContainer.ClearSyntaxErrors();

            _currentSources = SourceProvider.Sources;

            // Iterate over the source providers, parsing them one by one
            foreach (var source in _currentSources)
            {
                if (!source.ParseRequired) continue;

                var stream = new AntlrInputStream(source.GetScriptSourceString());
                ITokenSource lexer = new ZScriptLexer(stream);
                ITokenStream tokens = new CommonTokenStream(lexer);

                // TODO: See how to implement the bail error strategy correctly
                _parser = new ZScriptParser(tokens)
                {
                    BuildParseTree = true,
                    //Interpreter = { PredictionMode = PredictionMode.Sll },
                    //ErrorHandler = new BailErrorStrategy()
                };

                _parser.AddErrorListener(_syntaxErrorListener);

                _messageContainer.Source = source;

                try
                {
                    source.Tree = _parser.program();
                }
                    // Deal with parse exceptions
                catch (ParseCanceledException)
                {
                    _parser.ErrorHandler = new DefaultErrorStrategy();
                    _parser.Interpreter.PredictionMode = PredictionMode.Ll;

                    // Reset error listener
                    _messageContainer.ClearSyntaxErrors();

                    source.Tree = _parser.program();
                }

                source.ParseRequired = false;

                // Clear the definitions for the source file
                source.Definitions = null;

                // Attribute the source to the tree
                var sourceAttributer = new RuleContextSourceAttributer(source);

                sourceAttributer.Visit(source.Tree);
            }
        }

        /// <summary>
        /// Analyzes the program that was parsed, collecting definitions and raises warnings and errors for the code
        /// </summary>
        /// <returns>A code scope containing all of the definitions for the runtime</returns>
        public CodeScope CollectDefinitions()
        {
            if (RequiresParsing())
            {
                ParseSources();
            }

            var completeScope = new CodeScope();

            // Clear code errors and warnings that happened in previous definition collections
            _messageContainer.ClearCodeErrors();
            _messageContainer.ClearWarnings();

            foreach (var source in _currentSources)
            {
                if (source.Definitions == null)
                {
                    _messageContainer.Source = source;
                    
                    // Analyze the code of the scope
                    var collector = new DefinitionsCollector(_messageContainer);
                    collector.Collect(source.Tree);

                    source.Definitions = collector;
                }

                // Merge scopes
                completeScope = MergeScopes(completeScope, source.Definitions.CollectedBaseScope);
            }

            var context = CreateContext(completeScope);

            // Expand class definitions
            var classExpander = new ClassDefinitionExpander(context);
            classExpander.Expand();

            _nativeTypeBuilder.ClearCache();
            _nativeTypeBuilder.GenerationContext = context;

            // Walk the source trees, now that the definitions were collected
            var walker = new ParseTreeWalker();
            foreach (var source in _currentSources)
            {
                var varAnalyzer = new DefinitionAnalyzer(context) { Source = source };
                walker.Walk(varAnalyzer, source.Tree);
            }

            // Analyze the return of the scopes
            var returnAnalyzer = new ReturnStatementAnalyzer();
            returnAnalyzer.CollectReturnsOnDefinitions(context);

            // Expand the definitions contained within the collector
            var staticTypeAnalyzer = new StaticTypeAnalyzer(context);
            staticTypeAnalyzer.Analyze();

            returnAnalyzer.Analyze(context);

            // Analyze function parameters, now that they are all expanded
            var parameterAnalyzer = new FunctionParametersAnalyzer(context);
            parameterAnalyzer.Analyze();

            AnalyzeCollisions(completeScope);

            // Give another pass to classes: now verifying the methods
            classExpander.PostVerification();

            LastCodeScope = completeScope;

            return completeScope;
        }

        /// <summary>
        /// Generates a new runtime definition based on the script that was parsed.
        /// If the parsing has faild due to errors, an exception is raised
        /// </summary>
        /// <returns>A newly created ZRuntimeDefinition object that can be used to execute the parsed code</returns>
        /// <exception cref="Exception">Errors during the script generation did not allow a runtime definition to be generated</exception>
        public ZRuntimeDefinition GenerateRuntimeDefinition()
        {
            // Analyze the program
            var scope = CollectDefinitions();

            _messageContainer.PrintMessages();

            if (HasErrors)
            {
                throw new Exception("A runtime definition cannot be created: Errors detected during code parsing and analysis.");
            }

            // Create the class type converter
            var context = CreateContext(scope);

            _nativeTypeBuilder.CreateTypes(context);
            
            var runtimeDefinition = new ZRuntimeDefinition();

            // Collect the definitions now
            runtimeDefinition.AddFunctionDefs(GenerateFunctions(context));
            runtimeDefinition.AddGlobalVariables(GenerateGlobalVariables(context));
            runtimeDefinition.AddExportFunctionDefs(GenerateExportFunctions(context));
            runtimeDefinition.AddClosurenDefs(GenerateClosures(context));
            runtimeDefinition.AddClassDefinitions(GenerateClasses(context));

            // Expand the definitions in all of the list now
            var variableExpander = new VariableTokenExpander(runtimeDefinition.GetFunctions(), scope);
            var typedTokenExpander = new TypedTokenExpander(context);
            foreach (var function in runtimeDefinition.GetFunctions())
            {
                if (function.Tokens != null)
                {
                    variableExpander.ExpandInList(function.Tokens);
                }
            }
            // Expand global variables now
            foreach (var variable in runtimeDefinition.GlobalVariableDefinitions)
            {
                if (variable.ExpressionTokens != null)
                {
                    variableExpander.ExpandInList(variable.ExpressionTokens);
                    typedTokenExpander.ExpandInList(variable.ExpressionTokens);
                }
            }
            
            return runtimeDefinition;
        }

        /// <summary>
        /// Generates a new runtime based on the script that was parsed, setting the provided runtime owner as the owner of the runtime object to create
        /// If the parsing has faild due to errors, an exception is raised
        /// </summary>
        /// <param name="owner">A runtime owner object that will own the runtime to be created</param>
        /// <returns>A newly created ZRuntime object that can be used to execute the parsed code</returns>
        /// <exception cref="Exception">Errors during the script generation did not allow a runtime definition to be generated</exception>
        public ZRuntime GenerateRuntime(IRuntimeOwner owner)
        {
            return new ZRuntime(GenerateRuntimeDefinition(), owner);
        }

        /// <summary>
        /// Returns a value speicfying whether the generator requires parsing of source scripts
        /// </summary>
        /// <returns>true if the generator requires parsing, false otherwise</returns>
        private bool RequiresParsing()
        {
            return _currentSources == null || SourceProvider.Sources.Any(source => source.ParseRequired);
        }

        /// <summary>
        /// Returns a list of ZFunctions generated from a given code scope
        /// </summary>
        /// <param name="context">The context for the runtime generation</param>
        /// <returns>An array containing ZFunctions available at the top-level scope</returns>
        private IEnumerable<ZFunction> GenerateFunctions([JetBrains.Annotations.NotNull] RuntimeGenerationContext context)
        {
            var scope = context.BaseScope;

            var tokenizer = new FunctionBodyTokenizer(context) { DebugTokens = Debug };
            var funcDefs = scope.Definitions.OfType<FunctionDefinition>().Where(t => !(t is ExportFunctionDefinition) && !(t is ClosureDefinition) );
            var zFuncs = new List<ZFunction>();

            foreach (var funcDef in funcDefs)
            {
                var tokens = tokenizer.TokenizeBody(funcDef.BodyContext);

                funcDef.Tokens = tokens;

                var zFunction = new ZFunction(funcDef.Name, tokens, GenerateFunctionArguments(context, funcDef.Parameters), context.TypeProvider.NativeTypeForTypeDef(funcDef.ReturnType))
                {
                    Signature = funcDef.CallableTypeDef
                };

                zFuncs.Add(zFunction);
            }

            return zFuncs;
        }

        /// <summary>
        /// Returns a list of ZClasses generated from a given code scope
        /// </summary>
        /// <param name="context">The context for the runtime generation</param>
        /// <returns>An array containing ZClasses available at the top-level scope</returns>
        private IEnumerable<ZClass> GenerateClasses([JetBrains.Annotations.NotNull] RuntimeGenerationContext context)
        {
            var scope = context.BaseScope;

            var stmtTokenizer = new StatementTokenizerContext(context);
            var tokenizer = new FunctionBodyTokenizer(context) { DebugTokens = Debug };

            var classDefs = scope.Definitions.OfType<ClassDefinition>();
            var classes = new List<ZClass>();

            // Temporary dictionary used to help sort base methods
            var baseMethodQueue = new Dictionary<ZMethod, MethodDefinition>();
            // Dictionary of method definitions and their target transformed ZMethods. Used to setup the base calls
            var transformedMethods = new Dictionary<MethodDefinition, ZMethod>();

            foreach (var classDef in classDefs)
            {
                // Iterate over the methods
                var methods = new List<ZMethod>();

                foreach (var methodDef in classDef.GetAllMethods())
                {
                    var tokens = new TokenList();
                    if (methodDef.BodyContext != null)
                    {
                        tokens = tokenizer.TokenizeBody(methodDef.BodyContext);
                        methodDef.Tokens = tokens;
                    }

                    methodDef.RecreateCallableDefinition();

                    var method = new ZMethod(methodDef.Name, tokens, GenerateFunctionArguments(context, methodDef.Parameters), context.TypeProvider.NativeTypeForTypeDef(methodDef.ReturnType))
                    {
                        Signature = methodDef.CallableTypeDef
                    };

                    methods.Add(method);

                    transformedMethods[methodDef] = method;

                    if (methodDef.BaseMethod != null)
                        baseMethodQueue[method] = methodDef.BaseMethod;
                }

                var fields = new List<ZClassField>();

                foreach (var fieldDef in classDef.GetAllFields())
                {
                    var tokens = new TokenList();
                    if (fieldDef.HasValue)
                    {
                        tokens = new IntermediaryTokenList(stmtTokenizer.TokenizeExpression(fieldDef.ValueExpression.ExpressionContext)).ToTokenList();
                    }

                    var field = new ZClassField(fieldDef.Name, tokens)
                    {
                        Type = _typeProvider.NativeTypeForTypeDef(fieldDef.Type),
                        HasValue = fieldDef.HasValue
                    };

                    fields.Add(field);
                }

                var tokenList = new TokenList();

                if (classDef.PublicConstructor.BodyContext != null)
                    tokenList = tokenizer.TokenizeBody(classDef.PublicConstructor.BodyContext);

                classDef.PublicConstructor.Tokens = tokenList;

                var constructor = classDef.NonDefaultConstructor;

                tokenList = constructor.Tokens;

                // Tokenize constructor
                var zConstructor = new ZMethod(constructor.Name, tokenList, GenerateFunctionArguments(context, constructor.Parameters), context.TypeProvider.NativeTypeForTypeDef(classDef.ClassTypeDef));
                transformedMethods[constructor] = zConstructor;

                if (constructor.BaseMethod != null)
                    baseMethodQueue[zConstructor] = constructor.BaseMethod;

                classes.Add(new ZClass(classDef.Name, methods.ToArray(), fields.ToArray(), zConstructor, _nativeTypeBuilder.TypeForClassType(classDef.ClassTypeDef), constructor.RequiresBaseCall));
            }

            // Run over the base methods, setting the correct base methods now
            foreach (var zMethod in baseMethodQueue.Keys)
            {
                zMethod.BaseMethod = transformedMethods[baseMethodQueue[zMethod]];
            }

            return classes;
        }

        /// <summary>
        /// Returns a list of ZClosureFunction generated from a given code scope
        /// </summary>
        /// <param name="context">The context for the runtime generation</param>
        /// <returns>An array containing ZClosureFunction available at the top-level scope</returns>
        private IEnumerable<ZClosureFunction> GenerateClosures([JetBrains.Annotations.NotNull] RuntimeGenerationContext context)
        {
            var scope = context.BaseScope;

            var tokenizer = new FunctionBodyTokenizer(context) { DebugTokens = Debug };
            var closureDefs = scope.Definitions.OfType<ClosureDefinition>();
            var zClosures = new List<ZClosureFunction>();

            foreach (var funcDef in closureDefs)
            {
                var tokens = tokenizer.TokenizeBody(funcDef.BodyContext);

                funcDef.Tokens = tokens;

                var zFunction = new ZClosureFunction(funcDef.Name, tokens, GenerateFunctionArguments(context, funcDef.Parameters), context.TypeProvider.NativeTypeForTypeDef(funcDef.ReturnType))
                {
                    Signature = funcDef.CallableTypeDef
                };

                zClosures.Add(zFunction);
            }

            return zClosures;
        }

        /// <summary>
        /// Returns a list of ZFunctions generated from a given code scope
        /// </summary>
        /// <param name="context">The context for the runtime generation</param>
        /// <returns>An array containing ZFunctions available at the top-level scope</returns>
        private IEnumerable<ZExportFunction> GenerateExportFunctions([JetBrains.Annotations.NotNull] RuntimeGenerationContext context)
        {
            var scope = context.BaseScope;

            var funcDefs = scope.Definitions.OfType<ExportFunctionDefinition>();

            return funcDefs.Select(def => new ZExportFunction(def.Name, GenerateFunctionArguments(context, def.Parameters), context.TypeProvider.NativeTypeForTypeDef(def.ReturnType)));
        }

        /// <summary>
        /// Returns a list of GlobalVariables generated from a given code scope
        /// </summary>
        /// <param name="context">The context for the runtime generation</param>
        /// <returns>An array containing GlobalVariables available at the top-level scope</returns>
        private IEnumerable<GlobalVariable> GenerateGlobalVariables([JetBrains.Annotations.NotNull] RuntimeGenerationContext context)
        {
            var scope = context.BaseScope;

            var tokenizer = new StatementTokenizerContext(context);
            var varDefs = scope.Definitions.OfType<GlobalVariableDefinition>();

            return
                varDefs.Select(
                    def =>
                        new GlobalVariable
                        {
                            Name = def.Name,
                            HasValue = def.HasValue,
                            DefaultValue = null,
                            Type = _typeProvider.NativeTypeForTypeDef(def.Type),
                            ExpressionTokens = def.HasValue ? new TokenList(tokenizer.TokenizeExpression(def.ValueExpression.ExpressionContext)) : new TokenList()
                        });
        }

        /// <summary>
        /// Generates an array of function arguments from a specified enumerable of function argument definitions
        /// </summary>
        /// <param name="context">The context for the generation</param>
        /// <param name="arguments">An enumerable of function arguments read from the script</param>
        /// <returns>An array of function arguments generated from the given array of function argument definitions</returns>
        private static FunctionArgument[] GenerateFunctionArguments(RuntimeGenerationContext context, [JetBrains.Annotations.NotNull] IEnumerable<FunctionArgumentDefinition> arguments)
        {
            var listArgs = arguments.ToList();
            var retArgs = new FunctionArgument[listArgs.Count];

            for (int i = 0; i < listArgs.Count; i++)
            {
                var arg = listArgs[i];

                var type = context.TypeProvider.NativeTypeForTypeDef(arg.Type, true);

                if (arg.IsVariadic)
                {
                    type = context.TypeProvider.NativeTypeForTypeDef(((IListTypeDef)arg.Type).EnclosingType, true);
                }

                var defaultValue = arg.HasValue ? ConstantAtomParser.ParseCompileConstantAtom(arg.DefaultValue) : null;

                System.Diagnostics.Debug.Assert(type != null, nameof(type) + " != null");
                defaultValue = context.TypeProvider.CastObject(defaultValue, type);

                retArgs[i] = new FunctionArgument(arg.Name, arg.IsVariadic, arg.HasValue, defaultValue)
                {
                    Type = type
                };
            }

            return retArgs;
        }

        /// <summary>
        /// Merges two scopes into one containing all of the definitions of the two scopes.
        /// The method raises errors if one or more definitions collide
        /// </summary>
        /// <param name="source1">The first scope to merge</param>
        /// <param name="source2">The second scope to merge</param>
        /// <returns>A single code scope containing all of the definitions merged</returns>
        private static CodeScope MergeScopes([JetBrains.Annotations.NotNull] CodeScope source1, [JetBrains.Annotations.NotNull] CodeScope source2)
        {
            var newScope = new CodeScope();

            MergeScopesRecursive(source1, newScope);
            MergeScopesRecursive(source2, newScope);
            
            return newScope;
        }

        /// <summary>
        /// Merges the definitions of a code scope into another code scope, recursively re-creating the scope tree on the target scope
        /// </summary>
        /// <param name="source">The source scope to copy the definitions from</param>
        /// <param name="target">The second scope to copy the definitions to</param>
        private static void MergeScopesRecursive([JetBrains.Annotations.NotNull] CodeScope source, CodeScope target)
        {
            // Re-create the scope tree on the target
            foreach (var subScope in source.ChildrenScopes)
            {
                var scope = new CodeScope { Context = subScope.Context };
                target.AddSubscope(scope);

                MergeScopesRecursive(subScope, scope);
            }

            foreach (var d in source.Definitions)
            {
                target.AddDefinition(d);
            }
            foreach (var usage in source.DefinitionUsages)
            {
                target.AddDefinitionUsage(usage);
            }
        }

        /// <summary>
        /// Analyzes collisions of definitions in a given code scope
        /// </summary>
        private void AnalyzeCollisions([JetBrains.Annotations.NotNull] CodeScope scope)
        {
            var allDefs = scope.Definitions;

            foreach (var definition in allDefs)
            {
                var defs = scope.GetDefinitionsByName(definition.Name);

                foreach (var d in defs)
                {
                    if (d == definition)
                        continue;

                    // Collisions between exported definitions are ignored
                    if (d is ExportFunctionDefinition && !(definition is ExportFunctionDefinition) ||
                        definition is ExportFunctionDefinition && !(d is ExportFunctionDefinition))
                        continue;

                    // Shadowing of global variables
                    if (d is GlobalVariableDefinition && !(definition is GlobalVariableDefinition) ||
                        !(d is GlobalVariableDefinition) && definition is GlobalVariableDefinition)
                        continue;

                    int defLine = definition.Context?.Start.Line ?? 0;
                    int defColumn = definition.Context?.Start.Column ?? 0;

                    int dLine = d.Context?.Start.Line ?? 0;
                    int dColumn = d.Context?.Start.Column ?? 0;

                    string message = "Duplicated definition of '" + definition.Name + "' at line " + defLine +
                                     " column " + defColumn + " collides with definition " + d + " at line " + dLine +
                                     " column " + dColumn;

                    _messageContainer.RegisterError(definition.Context, message, ErrorCode.DuplicatedDefinition);
                }
            }
        }

        /// <summary>
        /// Default definition type provider for the runtime generator
        /// </summary>
        public class DefaultDefinitionTypeProvider : IDefinitionTypeProvider
        {
            /// <summary>
            /// A message container to report error messages and warnings to
            /// </summary>
            private readonly RuntimeGenerationContext _context;

            /// <summary>
            /// Stack of definitions, used to run through definitions in function bodies
            /// </summary>
            private readonly Stack<List<ValueHolderDefinition>> _localsStack;

            /// <summary>
            /// Initializes a new instance of the DefaultDefinitionTypeProvider class
            /// </summary>
            /// <param name="context">The runtime generation context for this default definition type provider</param>
            public DefaultDefinitionTypeProvider(RuntimeGenerationContext context)
            {
                _context = context;
                _localsStack = new Stack<List<ValueHolderDefinition>>();
            }

            /// <summary>
            /// Clears all the locals in the locals stack
            /// </summary>
            public void ClearLocalStack()
            {
                _localsStack.Clear();
            }

            /// <summary>
            /// Pushes a new definition scope
            /// </summary>
            public void PushLocalScope()
            {
                _localsStack.Push(new List<ValueHolderDefinition>());
            }

            /// <summary>
            /// Adds a given definition to the top of the definition stack
            /// </summary>
            /// <param name="definition">The definition to add to the top of the definition stack</param>
            public void AddLocal(ValueHolderDefinition definition)
            {
                _localsStack.Peek().Add(definition);
            }

            /// <summary>
            /// Pops a definition scope
            /// </summary>
            public void PopLocalScope()
            {
                _localsStack.Pop();
            }

#pragma warning disable CS1591 // O comentário XML ausente não foi encontrado para o tipo ou membro visível publicamente

            // 
            // IDefinitionTypeProvider.TypeForDefinition implementation
            // 
            public TypeDef TypeForDefinition([JetBrains.Annotations.NotNull] ZScriptParser.MemberNameContext context, string definitionName)
            {
                if (context.HasDefinition)
                {
                    var def = context.Definition;

                    if (def is LocalVariableDefinition)
                    {
                        goto local;
                    }

                    switch (def)
                    {
                        case ValueHolderDefinition holderDefinition:
                            context.IsConstant = holderDefinition.IsConstant;

                            return holderDefinition.Type ?? TypeDef.AnyType;

                        case FunctionDefinition funcDef:
                            // Functions cannot be reassigned
                            context.IsConstant = true;

                            return funcDef.CallableTypeDef;

                        case ClassDefinition objDef:
                            // Class definitions cannot be reassigned
                            context.IsConstant = true;

                            return objDef.PublicConstructor.CallableTypeDef;
                    }
                }

            local:
                foreach (var locals in _localsStack)
                {
                    var def = locals.FirstOrDefault(d => d.Name == definitionName);
                    if (def != null)
                    {
                        context.IsConstant = def.IsConstant;
                        context.Definition = def;
                        context.HasDefinition = true;

                        return def.Type;
                    }
                }

                _context.MessageContainer.Source = context.Source;

                _context.MessageContainer.RegisterError(context, "Cannot resolve definition name " + definitionName + " on type expanding phase.", ErrorCode.UndeclaredDefinition);
                return _context.TypeProvider.AnyType();
            }

            // 
            // IDefinitionTypeProvider.TypeForThis
            // 
            public TypeDef TypeForThis(ParserRuleContext context)
            {
                // Search for the inner-most scope that contains the context, and search the definition from there
                var scope = _context.BaseScope.GetScopeContainingContext(context);

                // Iterate back until we hit the scope for a class definition
                while (scope != null)
                {
                    if (scope.Context is ZScriptParser.ClassDefinitionContext definitionContext)
                    {
                        return definitionContext.ClassDefinition.ClassTypeDef;
                    }

                    scope = scope.ParentScope;
                }

                return _context.TypeProvider.AnyType();
            }

            // 
            // IDefinitionTypeProvider.TypeForBase
            // 
            public TypeDef TypeForBase(ParserRuleContext context)
            {
                // Search for the inner-most scope that contains the context, and search the definition from there
                var scope = _context.BaseScope.GetScopeContainingContext(context);

                // Iterate back until we hit the scope for a class definition
                while (scope != null)
                {
                    if (scope.Context is ZScriptParser.ClassMethodContext definitionContext)
                    {
                        if(definitionContext.MethodDefinition.BaseMethod != null)
                            return definitionContext.MethodDefinition.BaseMethod.CallableTypeDef;

                        break;
                    }
                    // Break on closures
                    if (scope.Context is ZScriptParser.ClosureExpressionContext)
                    {
                        break;
                    }

                    scope = scope.ParentScope;
                }

                return _context.TypeProvider.AnyType();
            }

            // 
            // IDefinitionTypeProvider.HasBaseTarget
            // 
            public bool HasBaseTarget(ParserRuleContext context)
            {
                // Search for the inner-most scope that contains the context, and search the definition from there
                var scope = _context.BaseScope.GetScopeContainingContext(context);

                // Iterate back until we hit the scope for a class definition
                while (scope != null)
                {
                    if (scope.Context is ZScriptParser.ClassMethodContext definitionContext)
                    {
                        if (definitionContext.MethodDefinition.BaseMethod != null)
                            return true;

                        break;
                    }
                    // Quit on closures with falsehood
                    if (scope.Context is ZScriptParser.ClosureExpressionContext)
                    {
                        return false;
                    }

                    scope = scope.ParentScope;
                }

                return false;
            }

#pragma warning restore CS1591 // O comentário XML ausente não foi encontrado para o tipo ou membro visível publicamente
        }

        /// <summary>
        /// Class used to generate native types from class definitions and tuple types and feed them to type providers during compilation
        /// </summary>
        private class NativeTypeBuilder : INativeTypeSource
        {
            /// <summary>
            /// The type building context for the native type builder
            /// </summary>
            private readonly TypeBuildingContext _typeBuildingContext;

            /// <summary>
            /// The class type builder this native source will use to build the classes
            /// </summary>
            private readonly ClassTypeBuilder _classTypeBuilder;

            /// <summary>
            /// The tuple type builder this native source will use to build the tuples
            /// </summary>
            private readonly TupleTypeBuilder _tupleTypeBuilder;

            /// <summary>
            /// A dictionary mapping class type defs to their respective native types
            /// </summary>
            private readonly Dictionary<ClassTypeDef, Type> _mappedClassTypes;

            /// <summary>
            /// Initializes a new instance of the ClassNativeTypeSource class
            /// </summary>
            /// <param name="assemblyName">The name for the assembly to generate and create the class types on</param>
            public NativeTypeBuilder([JetBrains.Annotations.NotNull] string assemblyName)
            {
                _typeBuildingContext = TypeBuildingContext.CreateBuilderContext(assemblyName);
                _classTypeBuilder = new ClassTypeBuilder(_typeBuildingContext);
                _tupleTypeBuilder = new TupleTypeBuilder(_typeBuildingContext);

                _mappedClassTypes = new Dictionary<ClassTypeDef, Type>();
            }

            /// <summary>
            /// Gets or sets the generation context for this native type builder
            /// </summary>
            public RuntimeGenerationContext GenerationContext { private get; set; }

            /// <summary>
            /// Creates the types on the runtime generation context provided on this class native type source
            /// </summary>
            public void CreateTypes([JetBrains.Annotations.NotNull] RuntimeGenerationContext generationContext)
            {
                GenerationContext = generationContext;

                ClearCache();

                var classDefinitions = generationContext.BaseScope.GetDefinitionsByType<ClassDefinition>();

                foreach (var classDefinition in classDefinitions)
                {
                    var nativeType = _classTypeBuilder.ConstructType(classDefinition);

                    _mappedClassTypes[classDefinition.ClassTypeDef] = nativeType;
                }
            }

            /// <summary>
            /// Clears all the class types registered on this class native type builder
            /// </summary>
            public void ClearCache()
            {
                _typeBuildingContext.ResetContext();

                _classTypeBuilder.ClearCache();
                _tupleTypeBuilder.ClearCache();
                _mappedClassTypes.Clear();
            }

            /// <summary>
            /// Returns a native type for the associated class type, or null, if none exists
            /// </summary>
            /// <param name="type">The class type to get</param>
            /// <returns>A native type that was associated with the given calss type at creation time, or null, if none exists</returns>
            [CanBeNull]
            public Type TypeForClassType([JetBrains.Annotations.NotNull] ClassTypeDef type)
            {
                return _mappedClassTypes.TryGetValue(type, out var native) ? native : null;
            }

            // 
            // INativeTypeSource.NativeTypeForTypeDef implementation
            // 
            [CanBeNull]
            public Type NativeTypeForTypeDef(TypeDef type, bool anyAsObject = false)
            {
                var classDef = type as ClassTypeDef;
                if (classDef != null) return TypeForClassType(classDef);

                var tupleDef = type as TupleTypeDef;
                if (tupleDef != null)
                {
                    var tuple = _tupleTypeBuilder.ConstructType(tupleDef);
                    return tuple.MakeGenericType(tupleDef.InnerTypes.Select(t => GenerationContext.TypeProvider.NativeTypeForTypeDef(t, true)).ToArray());
                }

                return null;
            }
        }
    }
}